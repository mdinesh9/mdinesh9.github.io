<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Dinesh's Journal - Micro Services</title><link href="http://localhost:8000/" rel="alternate"></link><link href="http://localhost:8000/feeds/micro-services.atom.xml" rel="self"></link><id>http://localhost:8000/</id><updated>2019-05-02T00:00:00+05:30</updated><entry><title>Micro Services / Using 12 factors for microservices in Production</title><link href="http://localhost:8000/micro-services-12-factors.html" rel="alternate"></link><published>2019-05-02T00:00:00+05:30</published><updated>2019-05-02T00:00:00+05:30</updated><author><name>Dinesh</name></author><id>tag:localhost,2019-05-02:/micro-services-12-factors.html</id><summary type="html">&lt;p&gt;How to handle transient issues in distributed systems and cloud environment.&lt;/p&gt;</summary><content type="html">&lt;p&gt;In our microservices deployment, we release several monolithic applications that interact with each other to achieve a specific goal. The experts at Heroku have formulated a set of 12 fundamental principles tailored for ensuring a successful microservices deployment.&lt;/p&gt;
&lt;p&gt;1.Codebase: &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maintain a single codebase per service.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Codebase(project) can contain one single repository or multiple repositories&lt;/p&gt;
&lt;p&gt;Our microservice should have a single codebase for each service tracked using version control, using a version control system, such as Git. This makes it easier to deploy and rollback changes easily to each individual service, and it also makes it easier to collaborate on the development of the microservice when there are changes that need to be made to the code, like a bugfix, feature, migration, and so on.&lt;/p&gt;
&lt;p&gt;Keeping code for each service in a seperate repo also helps us in preventing entire system to break and find the root cause, and fix the issue much faster.&lt;/p&gt;
&lt;p&gt;Under each service, we can have multiple deployment environments, such as&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;dev&lt;/li&gt;
&lt;li&gt;staging&lt;/li&gt;
&lt;li&gt;production&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;2.Dependencies&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Explicitly declare and isolate dependencies.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our microservice should explicitly declare and isolate its dependencies meaning for each external dependency, we should keep the version that we used when we were developing the service and those dependencies should be isolated from the rest of the system.&lt;/p&gt;
&lt;p&gt;For example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;requests=version_no&lt;/li&gt;
&lt;li&gt;Flask==version_no&lt;/li&gt;
&lt;li&gt;--extra-index-url https://download.pytorch.org/whl/cpu&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And each service should have its own version, like maybe one service requires one version of flask and another service might require another version of flask.&lt;/p&gt;
&lt;p&gt;If we dont maintain the version numbers, that means, every developer in our project might install a different version, and it might break our codebase, because of issues such as backwards incompatibility etc.&lt;/p&gt;
&lt;p&gt;3.Configuration&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Store configurations outside the code.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We should store all the configuration in environment variables, for example .env, or secret manager etc, rather than in the code itself. This makes it easier to deploy the microservice to different environments, and it also makes it easier to change the microservice's configuration without having to deploy a new version of the code.&lt;/p&gt;
&lt;p&gt;Also this helps us prevent releasing confidential information in repositories or to the public. &lt;/p&gt;
&lt;p&gt;4.Backing Services&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Treat services like databases as attached resources.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Supporting components and resources that our services depend on, such as databases, message queues, caching systems, and other external services are called backing services which can store data, communicate with other service, or perform specific tasks.&lt;/p&gt;
&lt;p&gt;Our services act as main actors in our project, and these backing services are crucial because our services depend on these for storing data, or facilitating communication between services.&lt;/p&gt;
&lt;p&gt;If any of these backing services become unavailable, it can disrupt overall performance. So, ensuring that these backing services are reliable, scalable, and easily accessible is crucial in the world of microservices to keep your applications running smoothly.&lt;/p&gt;
&lt;p&gt;So, we should be able to point our app to another instance which is running these backing services.&lt;/p&gt;
&lt;p&gt;5.Build, Release, Run&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Separate build, release, and run stages.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;We should seperate our services into build, release, and run stages. This means that the microservice should be built into a deployable artifact, such as a Docker image. This artifact can then be released to production and run in a variety of environments. This separation of stages makes it easier to automate the deployment and release of the microservice.&lt;/p&gt;
&lt;p&gt;The build stage is where you take your codebase and turn it into a runnable artifact. This could be a Docker image, or something else. The important thing is that the artifact is self-contained and can be run on any environment without any additional dependencies.&lt;/p&gt;
&lt;p&gt;The release stage is where you combine your build artifact with the configuration settings that your microservice needs to run. This configuration could include things like database connection strings, API keys, and environment variables. The release stage should also produce a unique identifier for each release. This will help you to track which versions of your microservices are running in production.&lt;/p&gt;
&lt;p&gt;The run stage is where you actually start and run your microservice. This could be done by deploying it to a container orchestration platform like Kubernetes, or by running it directly on a server.&lt;/p&gt;
&lt;p&gt;The important thing is that the build, release, and run stages are strictly separated. This means that you should be able to build, release, and run your microservices without making any changes to the codebase. This makes it easier to deploy new versions of your microservices and to roll back to previous versions if necessary.&lt;/p&gt;
&lt;p&gt;For example, in our Dockerfile, we can have different names for build, release, run etc. and push this to Artifact registry. &lt;/p&gt;
&lt;p&gt;6.Processes&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Execute the application as stateless processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our microservice should be stateless and should be executed as one or more identical processes. A  microservice should not maintain any state between requests. This makes it easier to scale the microservice horizontally by adding more instances of the process.&lt;/p&gt;
&lt;p&gt;Everything should be store in an external service, such as database or a cache.&lt;/p&gt;
&lt;p&gt;7.Port Binding&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Export services via a port and keep it self-contained.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Using port binding expose its services on a specific port. Other microservices can then communicate with the microservice by sending requests to that port. This makes it easy to discover and consume the microservice's services.&lt;/p&gt;
&lt;p&gt;8.Concurrency&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Scale horizontally by adding processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our microservice should scale horizontally by scaling out its processes to handle more concurrent requests by adding more servers. This makes it easier to handle spikes in traffic and to scale the microservice to meet the needs of a growing.&lt;/p&gt;
&lt;p&gt;Also this helps us reduce latency and achieve faster response time.&lt;/p&gt;
&lt;p&gt;9.Disposability&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Maximize robustness with fast startup and graceful shutdown.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;All the services of our microservices should be disposable, meaning that it can be started, stopped, and restarted quickly and efficiently. This is important for microservices because they are often deployed and scaled dynamically.&lt;/p&gt;
&lt;p&gt;10.Dev/Prod Parity&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Keep development and production environments as similar as possible.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Having deployed same version of aall our services in both Dev and Prod environments will help us test changes/features/bugfixes easier and deploy to production. With the help of CI/CD tools, we can easily achive this.&lt;/p&gt;
&lt;p&gt;11.Logs&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Treat logs as event streams.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our microservice should have structured logs that are easy to collect, search, and analyze which can help in debugging and troubleshooting problems with the microservice.&lt;/p&gt;
&lt;p&gt;12.Admin Processes&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Run admin tasks as one-off processes.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Our microservice should expose administrative interfaces for monitoring and managing the microservice. This is important for troubleshooting problems with the microservice and for scaling the microservice up and down.&lt;/p&gt;
&lt;p&gt;References:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;https://12factor.net/&lt;/li&gt;
&lt;/ul&gt;</content><category term="Micro Services"></category><category term="Micro Services"></category></entry></feed>